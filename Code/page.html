<!DOCTYPE html>
<!--Rutledge Dixon-->
<html>
<head id="header">
    <meta charset="utf-8" />
    <title>Texture???</title>
    <link rel="stylesheet" type="text/css" href="../css/page.css">
    <script id="vertex-shader" type="x-shader/x-vertex">

        //light stuff
        uniform vec3 u_Ambient_color;
        uniform vec3 u_Spotlight_position;
        uniform vec3 u_Spotlight_direction;
        uniform vec3 u_Spotlight_color;
        uniform float u_Spotlight_intensity;
        uniform float u_Spotlight_cone_angle;
        uniform float u_Spotlight_cutoff_angle;
        
        //basic vertex stuff
        varying vec4 v_Color;
        varying vec3 v_Position;
        varying vec3 v_Normal;

        //attribute stuff
        attribute vec3 a_Position;
        attribute vec3 a_Color;
        attribute vec3 a_Normal;

        //position stuff
        uniform mat4 u_rotateXMatrix;
        uniform mat4 u_rotateYMatrix;
        uniform mat4 u_rotateZMatrix;
        uniform mat4 u_scaleMatrix;
        uniform vec2 u_translate;

        void main(){
            //pass v_Color to the fragment shader
            v_Color = vec4(a_Color, 1.0);

            //apply transformations to the vertices
            vec4 translate = vec4(u_translate, 0, 0);
            vec4 position = vec4(a_Position, 1.0);
            
            // Apply transformations in correct order: scale first, then rotations
            vec4 transformedPosition = u_scaleMatrix * position;
            transformedPosition = u_rotateXMatrix * transformedPosition;
            transformedPosition = u_rotateYMatrix * transformedPosition;
            transformedPosition = u_rotateZMatrix * transformedPosition;
            transformedPosition = transformedPosition + translate;
            
            gl_Position = transformedPosition;
            
            // Pass world position for lighting calculations
            v_Position = transformedPosition.xyz;
            
            // Transform normal correctly - apply rotations in same order but don't scale or translate
            vec4 normal4 = vec4(a_Normal, 0.0);
            normal4 = u_rotateXMatrix * normal4;
            normal4 = u_rotateYMatrix * normal4;
            normal4 = u_rotateZMatrix * normal4;
            v_Normal = normalize(normal4.xyz);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        //light stuff
        uniform vec3 u_Ambient_color;
        uniform vec3 u_Spotlight_position;
        uniform vec3 u_Spotlight_direction;
        uniform vec3 u_Spotlight_color;
        uniform float u_Spotlight_intensity;
        uniform float u_Spotlight_cone_angle;
        uniform float u_Spotlight_cutoff_angle;
        
        varying vec4 v_Color;
        varying vec3 v_Position;
        varying vec3 v_Normal;

        void main()
        {
            vec3 baseColor = vec3(v_Color);
            
            // Ambient lighting
            vec3 ambient = u_Ambient_color * baseColor;
            
            // Spotlight calculations
            vec3 lightDirection = normalize(u_Spotlight_position - v_Position);
            vec3 spotDirection = normalize(-u_Spotlight_direction);
            
            // Calculate angle between light direction and spot direction
            float theta = dot(lightDirection, spotDirection);
            float epsilon = u_Spotlight_cone_angle - u_Spotlight_cutoff_angle;
            float spotIntensity = clamp((theta - u_Spotlight_cutoff_angle) / epsilon, 0.0, 1.0);
            
            // Distance attenuation, wow :000000
            float distance = length(u_Spotlight_position - v_Position);
            float attenuation = 1.0 / (1.0 + 0.1 * distance + 0.01 * distance * distance);
            
            // Diffuse lighting - use abs() around dot product to make lighting work on both sides
            vec3 normal = normalize(v_Normal);
            float diff = abs(dot(normal, lightDirection));
            vec3 diffuse = diff * u_Spotlight_color * baseColor * u_Spotlight_intensity;
            
            // Combine lighting
            vec3 result = ambient + (diffuse * spotIntensity * attenuation);
            
            gl_FragColor = vec4(result, v_Color.a);
        }
    </script>
    <script src="../common/webgl-utils.js"></script>
    <script src="../common/webgl-debug.js"></script>
    <script src="../common/cuon-utils-letu.js"></script>
    <script src="../common/cuon-matrix.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js" integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ==" crossorigin="anonymous" defer></script>   
    <script src="page.js"></script>

</head>

<body class="body-container" onload="main()">
    <div class="header-container">
        <h1>Textures?</h1>
    </div>
    <div class="main-container">
        <canvas id="webgl" width="512" height="512">
            Oops ... your browser doesn't support the HTML5 canvas element
        </canvas>
        <div class="controls">
            <h3>Toggle:</h3>
            <h4> - 't' : animation</h4>
            <h4> - spacebar : objects</h4>
            <button onclick="toggleAnimationWithButton()">
                Toggle Animation
            </button>
            <p id="loserText" style="margin: 1px;"> </p>
        </div>
    </div>
    
</body>
</html>